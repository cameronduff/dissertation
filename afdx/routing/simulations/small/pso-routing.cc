#include "pso-routing.h"

#include "ns3/ipv4-header.h"
#include "ns3/ipv4-routing-protocol.h"
#include "ns3/ipv4-interface-address.h"
#include "ns3/ipv4-interface.h"
#include "ns3/ipv4-global-routing.h"
#include "ns3/ipv4.h"
#include "ns3/ipv4-route.h"
#include "ns3/ipv4-address.h"
#include "ns3/ptr.h"
#include "ns3/log.h"
#include "ns3/ipv4-routing-table-entry.h"
#include "ns3/node-list.h"
#include "ns3/global-router-interface.h"
#include "ns3/global-route-manager-impl.h"

#include <list>
#include <string>
#include <stdint.h>
#include <bits/stdc++.h>

using namespace std;

namespace ns3
{
    NS_LOG_COMPONENT_DEFINE ("PSOProtocol");

    PSO::PSO()
    {

    }
    PSO::~PSO()
    {
            
    }

    // RouteOutput is used for packets generated by the node, and it's used to find
    // the correct output interface, the source address (if needed), and the next
    // hop (if needed)
    Ptr<Ipv4Route> PSO::RouteOutput(Ptr<Packet> p,
                            const Ipv4Header& header,
                            Ptr<NetDevice> oif,
                            Socket::SocketErrno& sockerr)
    {
         return nullptr;   
    }

    // RouteInput is used for packets received by the node, and checks if the 
    // packet is for the node or has to be forwarded (and if so, what is the 
    // next hop).
    bool PSO::RouteInput(Ptr<const Packet> p,
                    const Ipv4Header& header,
                    Ptr<const NetDevice> idev,
                    const UnicastForwardCallback& ucb,
                    const MulticastForwardCallback& mcb,
                    const LocalDeliverCallback& lcb,
                    const ErrorCallback& ecb)
    {
            return false;
    }

    void PSO::NotifyInterfaceUp(uint32_t interface)
    {
            
    }
    void PSO::NotifyInterfaceDown(uint32_t interface)
    {
            
    }
    void PSO::NotifyAddAddress(uint32_t interface, Ipv4InterfaceAddress address)
    {
            
    }
    void PSO::NotifyRemoveAddress(uint32_t interface, Ipv4InterfaceAddress address)
    {
            
    }
    void PSO::SetIpv4(Ptr<Ipv4> ipv4)
    {
            
    }
    void PSO::PrintRoutingTable(Ptr<OutputStreamWrapper> stream, Time::Unit unit) const
    {
            
    }

    void PSO::RecomputeRoutingTables()
    {

    }

    int minDistance(int distance[], bool shortestPath[])
    {
        int min = INT_MAX, min_index;
    
        for (int v = 0; v < int(NodeList::GetNNodes()); v++){
            if (shortestPath[v] == false && distance[v] <= min){
                min = distance[v], min_index = v;
            }
        }

        return min_index;
    }

    void PSO::returnPath(int currentVertex, vector<int> parents, vector<int> &path)
    {
        if (currentVertex == -1) {
            return;
        }
        returnPath(parents[currentVertex], parents, path);
        path.push_back(currentVertex);
    }

    bool PSO::checkIfRouteExists(Ptr<Ipv4GlobalRouting> gr, Ipv4Route route)
    {
        for(uint32_t i=0; i<gr->GetNRoutes(); i++){
            Ipv4RoutingTableEntry routingTableEntry = gr->GetRoute(i);
            if(routingTableEntry.GetDest() == route.GetDestination() && 
                routingTableEntry.GetGateway() == route.GetGateway()){
                return true;
            }
        }

        return false;
    }

    void PSO::returnShortestPath(int startVertex, vector<int> distances, vector<int> parents)
    {
        int nVertices = distances.size();
        NS_LOG_INFO("Vertex\t Distance\tPath");
        VirtualLink virtualLink;
    
        for (int vertexIndex = 0; vertexIndex < nVertices; vertexIndex++) {
            if (vertexIndex != startVertex) {
                vector<int> path;
                returnPath(vertexIndex, parents, path);

                virtualLink.srcNode = startVertex;
                virtualLink.dstNode = vertexIndex;
                virtualLink.path = path;
                virtualLink.fitness=1.0;
                _virtualLinks.push_back(virtualLink);
                
                string pathString("");
                for(int i=0; i<int(path.size()); i++){
                    auto s = std::to_string(path[i]);
                    pathString = pathString + s + " ";
                }

                NS_LOG_INFO(startVertex << " -> " << vertexIndex << " \t\t " << distances[vertexIndex] << "\t" << pathString);

                int pathSize = path.size();

                for(int j=0; j<pathSize-1; j++)
                {
                    Ptr<Node> currentNode = NodeList::GetNode(path[j]);
                    Ptr<Node> gatewayNode = NodeList::GetNode(path[j+1]);
                    Ptr<Node> destinationNode = NodeList::GetNode(vertexIndex);

                    // NS_LOG_INFO("Node " << path[j]);

                    for(uint32_t ip=1; ip<destinationNode->GetNDevices(); ip++){
                        Ipv4Route route;
                        Ipv4Mask mask = Ipv4Mask("255.255.255.0");
                        Ipv4Address destNetwork = destinationNode->GetObject<Ipv4>()->GetAddress(ip,0).GetLocal().CombineMask(mask);
                        
                        uint32_t interface = ip;

                        //checks if destination is on the same network as the source
                        //if true, no need for a gateway (0.0.0.0)
                        if(currentNode->GetObject<Ipv4>()->GetAddress(1, 0).GetLocal().CombineMask(mask) == destNetwork) {
                            route.SetGateway(Ipv4Address("0.0.0.0"));
                        } else{
                            bool same = false;

                            //loops through to see if the current node and gateway node share a network
                            for(uint32_t i=1; i<currentNode->GetNDevices(); i++){
                                for(uint32_t j=1; j<gatewayNode->GetNDevices(); j++){
                                    Ipv4Address currentNetwork = currentNode->GetObject<Ipv4>()->GetAddress(i, 0).GetLocal().CombineMask(mask);
                                    Ipv4Address nextNetwork = gatewayNode->GetObject<Ipv4>()->GetAddress(j, 0).GetLocal().CombineMask(mask);

                                    //sets the gateway to the same network
                                    if(currentNetwork == nextNetwork){
                                        route.SetGateway(gatewayNode->GetObject<Ipv4>()->GetAddress(j, 0).GetLocal());
                                        interface = i;
                                        same = true;
                                    }
                                }
                            }
                                
                            if(!same){
                                route.SetGateway(gatewayNode->GetObject<Ipv4>()->GetAddress(1, 0).GetLocal());
                            }
                        }

                        route.SetDestination(destinationNode->GetObject<Ipv4>()->GetAddress(ip,0).GetLocal().CombineMask(mask));
                        // Ptr<Ipv4GlobalRouting> gr = NodeList::GetNode(path[j])->GetObject<GlobalRouter>()->GetRoutingProtocol();

                        // // turn off for debugging
                        // if(!checkIfRouteExists(gr, route))
                        // {   
                        //     NS_LOG_INFO("Dest: " << route.GetDestination() << " Gateway: " << route.GetGateway() << " Interface:" << interface);
                        //     gr->AddNetworkRouteTo(route.GetDestination(), mask, route.GetGateway(), interface);
                        // }
                    }

                    // NS_LOG_INFO(" ");
                }
            }
        }
    }

    void PSO::BuildGlobalRoutingDatabase()
    {
        NS_LOG_INFO("Building Global Routing Database");
        //database of all connections
        int adjacencyMatrix[NodeList::GetNNodes()][NodeList::GetNNodes()];

        NS_LOG_INFO("Creating initial adjacency matrix values");
        for(int x=0; x<int(NodeList::GetNNodes()); x++){
            for(int y=0; y<int(NodeList::GetNNodes()); y++){
                adjacencyMatrix[x][y] = 0;
            }
        }

        NS_LOG_INFO("Populating adjacency matrix values");
        for (uint32_t i=0; i<NodeList::GetNNodes(); i++)
        {
            Ptr<Node> node = NodeList::GetNode(i);

            for (uint32_t j=0; j<node->GetNDevices() -1; j++)
            {
                Ptr<NetDevice> netDevice = node->GetDevice(j);   
                Ptr<Channel> channel = netDevice->GetChannel();

                for(uint32_t l=0; l<channel->GetNDevices(); l++)
                {
                    Ptr<NetDevice> channelDevice = channel->GetDevice(l);
                    uint32_t id = channelDevice->GetNode()->GetId();
                    // default weighting (fitness) is set to 1
                    adjacencyMatrix[node->GetId()][id] = 1;
                }
            }   
        }

        //  NS_LOG_INFO("Output matrix");
            for(int x=0; x<int(NodeList::GetNNodes()); x++){
            string row("");
            for(int y=0; y<int(NodeList::GetNNodes()); y++){
                auto s = std::to_string(adjacencyMatrix[x][y]);
                row = row + s;
            }
            NS_LOG_INFO("Node Id: " << x << " " << row);
        }

        NS_LOG_INFO("");

        //start finding smallest route assuming equal link weighting
        NS_LOG_INFO("Finding shortest routes");

        for(int src=0; src<int(NodeList::GetNNodes()); src++)
        {
            int nVertices = int(NodeList::GetNNodes());
            vector<int> shortestDistances(nVertices);
            vector<bool> added(nVertices);

            for (int vertexIndex = 0; vertexIndex < nVertices; vertexIndex++)
            {
                shortestDistances[vertexIndex] = INT_MAX;
                added[vertexIndex] = false;
            }
            
            shortestDistances[src] = 0;
            vector<int> parents(nVertices);
            parents[src] = -1;
        
            for (int i = 1; i < nVertices; i++) 
            {
                int nearestVertex = -1;
                int shortestDistance = INT_MAX;

                for (int vertexIndex = 0; vertexIndex < nVertices;
                    vertexIndex++) {
                    if (!added[vertexIndex] && shortestDistances[vertexIndex] < shortestDistance) {
                        nearestVertex = vertexIndex;
                        shortestDistance = shortestDistances[vertexIndex];
                    }
                }

                added[nearestVertex] = true;

                for (int vertexIndex = 0; vertexIndex < nVertices; vertexIndex++) {
                    int edgeDistance = adjacencyMatrix[nearestVertex][vertexIndex];
        
                    if (edgeDistance > 0 && ((shortestDistance + edgeDistance) < shortestDistances[vertexIndex])) {
                        parents[vertexIndex] = nearestVertex;
                        shortestDistances[vertexIndex] = shortestDistance + edgeDistance;
                    }
                }
            }

            returnShortestPath(src, shortestDistances, parents);
        }
        NS_LOG_INFO("Routing tables populated");

        
        for(int i; i<_virtualLinks.size(); i++){
            NS_LOG_INFO(_virtualLinks[i].srcNode << " -> " << _virtualLinks[i].dstNode);
            
            for(int j=0; j<_virtualLinks[i].path.size(); j++){
                NS_LOG_INFO(_virtualLinks[i].path[j]);
            }

        }
    }

    void PSO::ComputeRoutingTables()
    {
        BuildGlobalRoutingDatabase();
    }
}