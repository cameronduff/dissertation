#include "ns3/ipv4-header.h"
#include "ns3/ipv4-routing-protocol.h"
#include "ns3/ipv4-interface-address.h"
#include "ns3/ipv4-interface.h"
#include "ns3/ipv4-global-routing.h"
#include "ns3/ipv4.h"
#include "ns3/ipv4-route.h"
#include "ns3/ipv4-address.h"
#include "ns3/ptr.h"
#include "ns3/log.h"
#include "ns3/ipv4-routing-table-entry.h"
#include "ns3/node-list.h"
#include "ns3/global-router-interface.h"
#include "ns3/global-route-manager-impl.h"

#include <list>
#include <string>
#include <stdint.h>
#include <bits/stdc++.h>

using namespace std;

namespace ns3{
    // export NS_LOG=PSORoutingProtocol
    NS_LOG_COMPONENT_DEFINE ("PSORoutingProtocol");

    class PSORoutingProtocol : public Ipv4GlobalRouting
    {
        public:
            PSORoutingProtocol(){
                NS_LOG_FUNCTION(this);
            }

            static void PopulateRoutingTables() 
            {
                PSORoutingProtocol::BuildGlobalRoutingDatabase();
            }

            // RouteOutput is used for packets generated by the node, and it's used to find
            // the correct output interface, the source address (if needed), and the next
            // hop (if needed)
            Ptr<Ipv4Route> RouteOutput(Ptr<Packet> p,
                                    const Ipv4Header& header,
                                    Ptr<NetDevice> oif,
                                    Socket::SocketErrno& sockerr) {
                NS_LOG_INFO("In RouteOutput");
                return nullptr;
            }

            // RouteInput is used for packets received by the node, and checks if the 
            // packet is for the node or has to be forwarded (and if so, what is the 
            // next hop).
            bool RouteInput(Ptr<const Packet> p,
                            const Ipv4Header& header,
                            Ptr<const NetDevice> idev,
                            const UnicastForwardCallback& ucb,
                            const MulticastForwardCallback& mcb,
                            const LocalDeliverCallback& lcb,
                            const ErrorCallback& ecb) {
                NS_LOG_INFO("In RouteInput");
                return false;
            }
        private:
            static void BuildGlobalRoutingDatabase()
            {
                NS_LOG_INFO("Building Global Routing Database");
                //database of all connections
                int adjacencyMatrix[NodeList::GetNNodes()][NodeList::GetNNodes()];

                NS_LOG_INFO("Creating initial adjacency matrix values");
                for(int x=0; x<int(NodeList::GetNNodes()); x++){
                    for(int y=0; y<int(NodeList::GetNNodes()); y++){
                        adjacencyMatrix[x][y] = 0;
                    }
                }

                NS_LOG_INFO("Populating adjacency matrix values");
                for (uint32_t i=0; i<NodeList::GetNNodes(); i++)
                {
                    Ptr<Node> node = NodeList::GetNode(i);

                    for (uint32_t j=0; j<node->GetNDevices() -1; j++)
                    {
                        Ptr<NetDevice> netDevice = node->GetDevice(j);   
                        Ptr<Channel> channel = netDevice->GetChannel();

                        for(uint32_t l=0; l<channel->GetNDevices(); l++)
                        {
                            Ptr<NetDevice> channelDevice = channel->GetDevice(l);
                            uint32_t id = channelDevice->GetNode()->GetId();
                            // default weighting (fitness) is set to 1
                            adjacencyMatrix[node->GetId()][id] = 1;
                        }
                    }   
                }

                //  NS_LOG_INFO("Output matrix");
                 for(int x=0; x<int(NodeList::GetNNodes()); x++){
                    string row("");
                    for(int y=0; y<int(NodeList::GetNNodes()); y++){
                        auto s = std::to_string(adjacencyMatrix[x][y]);
                        row = row + s;
                    }
                    // NS_LOG_INFO("Node Id: " << x << " " << row);
                }

                // NS_LOG_INFO("");

                //start finding smallest route assuming equal link weighting
                NS_LOG_INFO("Finding shortest routes");
                for(int src=0; src<int(NodeList::GetNNodes()); src++)
                {
                    int nVertices = int(NodeList::GetNNodes());
                    vector<int> shortestDistances(nVertices);
                    vector<bool> added(nVertices);

                    for (int vertexIndex = 0; vertexIndex < nVertices; vertexIndex++)
                    {
                        shortestDistances[vertexIndex] = INT_MAX;
                        added[vertexIndex] = false;
                    }
                    
                    shortestDistances[src] = 0;
                    vector<int> parents(nVertices);
                    parents[src] = -1;
                
                    for (int i = 1; i < nVertices; i++) 
                    {
                        int nearestVertex = -1;
                        int shortestDistance = INT_MAX;

                        for (int vertexIndex = 0; vertexIndex < nVertices;
                            vertexIndex++) {
                            if (!added[vertexIndex] && shortestDistances[vertexIndex] < shortestDistance) {
                                nearestVertex = vertexIndex;
                                shortestDistance = shortestDistances[vertexIndex];
                            }
                        }

                        added[nearestVertex] = true;

                        for (int vertexIndex = 0; vertexIndex < nVertices; vertexIndex++) {
                            int edgeDistance = adjacencyMatrix[nearestVertex][vertexIndex];
                
                            if (edgeDistance > 0 && ((shortestDistance + edgeDistance) < shortestDistances[vertexIndex])) {
                                parents[vertexIndex] = nearestVertex;
                                shortestDistances[vertexIndex] = shortestDistance + edgeDistance;
                            }
                        }
                    }

                    returnShortestPath(src, shortestDistances, parents);
                }
                NS_LOG_INFO("Routing tables populated");
            }

            static void InitializeRoutes()
            {
                
            }

            static int minDistance(int distance[], bool shortestPath[])
            {
                int min = INT_MAX, min_index;
            
                for (int v = 0; v < int(NodeList::GetNNodes()); v++){
                    if (shortestPath[v] == false && distance[v] <= min){
                        min = distance[v], min_index = v;
                    }
                }

                return min_index;
            }

            static void returnShortestPath(int startVertex, vector<int> distances, vector<int> parents)
            {
                int nVertices = distances.size();
                // NS_LOG_INFO("Vertex\t Distance\tPath");
            
                for (int vertexIndex = 0; vertexIndex < nVertices; vertexIndex++) {
                    if (vertexIndex != startVertex) {
                        vector<int> path;
                        returnPath(vertexIndex, parents, path);
                        
                        string pathString("");
                        for(int i=0; i<int(path.size()); i++){
                            auto s = std::to_string(path[i]);
                            pathString = pathString + s + " ";
                        }

                        NS_LOG_INFO(startVertex << " -> " << vertexIndex << " \t\t " << distances[vertexIndex] << "\t" << pathString);

                        int pathSize = path.size();

                        for(int j=0; j<pathSize-1; j++)
                        {
                            Ptr<Node> currentNode = NodeList::GetNode(path[j]);
                            Ptr<Node> gatewayNode = NodeList::GetNode(path[j+1]);
                            Ptr<Node> destinationNode = NodeList::GetNode(vertexIndex);

                            // NS_LOG_INFO("Node " << path[j]);
                            // NS_LOG_INFO("Num of devices: " << currentNode->GetNDevices());

                            for(uint32_t ip=1; ip<destinationNode->GetNDevices(); ip++){
                                Ipv4Route route;
                                Ipv4Mask mask = Ipv4Mask("255.255.255.0");
                                Ipv4Address destNetwork = destinationNode->GetObject<Ipv4>()->GetAddress(ip,0).GetLocal().CombineMask(mask);
                                
                                uint32_t interface = ip;

                                //checks if destination is on the same network as the source
                                //if true, no need for a gateway (0.0.0.0)
                                if(currentNode->GetObject<Ipv4>()->GetAddress(1, 0).GetLocal().CombineMask(mask) == destNetwork) {
                                    route.SetGateway(Ipv4Address("0.0.0.0"));
                                } else{
                                    bool same = false;

                                    //loops through to see if the current node and gateway node share a network
                                    for(uint32_t i=1; i<currentNode->GetNDevices(); i++){
                                        for(uint32_t j=1; j<gatewayNode->GetNDevices(); j++){
                                            Ipv4Address currentNetwork = currentNode->GetObject<Ipv4>()->GetAddress(i, 0).GetLocal().CombineMask(mask);
                                            Ipv4Address nextNetwork = gatewayNode->GetObject<Ipv4>()->GetAddress(j, 0).GetLocal().CombineMask(mask);

                                            //sets the gateway to the same network
                                            if(currentNetwork == nextNetwork){
                                                route.SetGateway(gatewayNode->GetObject<Ipv4>()->GetAddress(j, 0).GetLocal());
                                                interface = i;
                                                same = true;
                                            }
                                        }
                                    }
                                        
                                    if(!same){
                                        route.SetGateway(gatewayNode->GetObject<Ipv4>()->GetAddress(1, 0).GetLocal());
                                    }
                                }

                                route.SetDestination(destinationNode->GetObject<Ipv4>()->GetAddress(ip,0).GetLocal().CombineMask(mask));
                                Ptr<Ipv4GlobalRouting> gr = NodeList::GetNode(path[j])->GetObject<GlobalRouter>()->GetRoutingProtocol();

                                // turn off for debugging
                                if(!checkIfRouteExists(gr, route))
                                {   
                                    // NS_LOG_INFO("Dest: " << route.GetDestination() << " Gateway: " << route.GetGateway() << " Interface:" << interface);
                                    gr->AddNetworkRouteTo(route.GetDestination(), mask, route.GetGateway(), interface);
                                }
                            }

                            // NS_LOG_INFO(" ");
                        }
                    }
                }
            }

            static void returnPath(int currentVertex, vector<int> parents, vector<int> &path)
            {
                if (currentVertex == -1) {
                    return;
                }
                returnPath(parents[currentVertex], parents, path);
                path.push_back(currentVertex);
            }

            static bool checkIfRouteExists(Ptr<Ipv4GlobalRouting> gr, Ipv4Route route)
            {
                for(uint32_t i=0; i<gr->GetNRoutes(); i++){
                    Ipv4RoutingTableEntry routingTableEntry = gr->GetRoute(i);
                    if(routingTableEntry.GetDest() == route.GetDestination() && 
                        routingTableEntry.GetGateway() == route.GetGateway()){
                        return true;
                    }
                }

                return false;
            }
    };
}   //namespace ns3

using ns3::g_log;